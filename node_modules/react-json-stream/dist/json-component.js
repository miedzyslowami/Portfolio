'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReactMultiChild = require('react/lib/ReactMultiChild');
var JSONMount = require('./json-mount');
var includes = require('lodash.includes');
var filter = require('lodash.filter');
var zip = require('lodash.zipobject');
var pairs = require('lodash.pairs');
var isArray = require('lodash.isarray');
var assign = require('lodash.assign');
var rest = require('lodash.rest');
var isUndefined = require('lodash.isundefined');
var defaults = require('lodash.defaults');
var isNull = require('lodash.isnull');
var format = require('util').format;

var CONTENT_TYPES = ['string', 'number'];

var exists = function exists(v) {
  return !isNull(v) && !isUndefined(v);
};

var noop = function noop() {};

var Component = (function () {
  function Component(tag) {
    _classCallCheck(this, Component);

    this._tag = tag.toLowerCase();
    this._rootNodeID = null;
    this._renderedChildren = null;
  }

  _createClass(Component, [{
    key: 'construct',
    value: function construct(element) {
      this._currentElement = element;
    }
  }, {
    key: 'mountComponent',
    value: function mountComponent(rootID, transaction, context) {
      this._rootNodeID = rootID;

      if (isArray(this._currentElement.props.children)) {
        this._mountChildren(transaction, context);
      }

      return this._mountNode();
    }
  }, {
    key: '_mountChildren',
    value: function _mountChildren(transaction, context) {
      this.mountChildren(this._currentElement.props.children, transaction, context);
    }
  }, {
    key: '_content',
    value: function _content() {
      var children = this._currentElement.props.children;

      if (isArray(children)) {
        return null;
      }

      if (!includes(CONTENT_TYPES, typeof children === 'undefined' ? 'undefined' : _typeof(children))) {
        return null;
      }

      return children;
    }
  }, {
    key: '_props',
    value: function _props() {
      var key = this._currentElement.key;

      return defaults({
        key: exists(key) ? key : noop()
      }, zip(filter(pairs(this._currentElement.props), function (kv) {
        return kv[0] !== 'children';
      })));
    }
  }, {
    key: '_mountNode',
    value: function _mountNode() {
      var path = this._rootNodeID.split(/\./).filter(Boolean);
      var parent = rest(path.reverse()).reverse();

      var node = {
        parent: parent.length ? format('.%s', parent.join('.')) : '',
        name: this._currentElement.type,
        id: this._rootNodeID,
        props: this._props(),
        content: this._content()
      };

      return JSONMount.setNode(this._rootNodeID, node);
    }
  }, {
    key: '_updateComponent',
    value: function _updateComponent(transaction, prev, next, context) {
      var getContent = function getContent(children) {
        return includes(CONTENT_TYPES, typeof children === 'undefined' ? 'undefined' : _typeof(children)) ? children : null;
      };

      var getHTML = function getHTML(dangerouslySetInnerHTML) {
        return dangerouslySetInnerHTML && dangerouslySetInnerHTML.__html;
      };

      var getChildren = function getChildren(content, children) {
        return exists(content) ? null : children;
      };

      var hasContentOrHtml = function hasContentOrHtml(content, html) {
        return exists(content) || exists(html);
      };

      var shouldRemove = function shouldRemove(what) {
        return exists(what.prev) && !exists(what.next);
      };

      var shouldUpdate = function shouldUpdate(what) {
        return exists(what.next) && what.prev !== what.next;
      };

      var content = {
        prev: getContent(prev.props.children),
        next: getContent(next.props.children)
      };

      var html = {
        prev: getHTML(prev.props.dangerouslySetInnerHTML),
        next: getHTML(next.props.dangerouslySetInnerHTML)
      };

      var children = {
        prev: getChildren(content.prev, prev.props.children),
        next: getChildren(content.next, next.props.children)
      };

      var contentOrHtml = {
        prev: hasContentOrHtml(content.prev, html.prev),
        next: hasContentOrHtml(content.next, html.next)
      };

      var remove = {
        children: shouldRemove(children),
        content: shouldRemove(contentOrHtml)
      };

      var update = {
        content: shouldUpdate(content),
        html: shouldUpdate(html),
        children: exists(children.next)
      };

      if (remove.children) {
        this.updateChildren(null, transaction, context);
      } else if (remove.content) {
        this.updateTextContent('');
      }

      if (update.content) {
        this.updateTextContent(String(content.next));
      } else if (update.html) {
        this.updateMarkup(String(html.next));
      } else if (update.children) {
        this.updateChildren(children.next, transaction, context);
      }

      return this._mountNode();
    }
  }, {
    key: 'receiveComponent',
    value: function receiveComponent(element, transaction, context) {
      var prev = this._currentElement;
      this._currentElement = element;
      return this._updateComponent(transaction, prev, element, context);
    }
  }, {
    key: 'unmountComponent',
    value: function unmountComponent() {
      JSONMount.purgeId(this._rootNodeID);
      this.unmountChildren();
      this._rootNodeID = null;
    }
  }, {
    key: 'getPublicInstance',
    value: function getPublicInstance() {}
  }]);

  return Component;
})();

assign(Component.prototype, ReactMultiChild.Mixin);

module.exports = Component;