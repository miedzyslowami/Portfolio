"use strict";

require("jest-dom/extend-expect");

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

var _reactTestingLibrary = require("react-testing-library");

var _ = require("./");

var _2 = _interopRequireDefault(_);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

afterEach(_reactTestingLibrary.cleanup);

var worker = { onmessage: null, postMessage: jest.fn(), terminate: jest.fn() };
var serviceWorker = { postMessage: jest.fn() };
var messageChannel = { port1: {}, port2: jest.fn() };
window.Worker = jest.fn().mockImplementation(function () {
  return worker;
});
window.ServiceWorker = jest.fn().mockImplementation(function () {
  return serviceWorker;
});
window.MessageChannel = jest.fn().mockImplementation(function () {
  return messageChannel;
});

test("initializes a Worker on mount", function () {
  var options = {};
  (0, _reactTestingLibrary.render)(_react2.default.createElement(_2.default, { url: "/worker.js", options: options }));
  expect(window.Worker).toHaveBeenCalledWith("/worker.js", options);
});

test("passes received messages to children as render prop", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
  var _render, getByText;

  return regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _render = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            function (_ref2) {
              var messages = _ref2.messages;
              return messages.map(function (m) {
                return m.data;
              }).join();
            }
          )), getByText = _render.getByText;

          worker.onmessage({ data: "foo" });
          worker.onmessage({ data: "bar" });
          worker.onmessage({ data: "baz" });
          _context.next = 6;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("foo,bar,baz");
          });

        case 6:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, undefined);
})));

test("passes data of last received message to children as render prop", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
  var _render2, getByText;

  return regeneratorRuntime.wrap(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _render2 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            function (_ref4) {
              var data = _ref4.data;
              return data;
            }
          )), getByText = _render2.getByText;

          worker.onmessage({ data: "foo" });
          worker.onmessage({ data: "bar" });
          worker.onmessage({ data: "baz" });
          _context2.next = 6;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("baz");
          });

        case 6:
        case "end":
          return _context2.stop();
      }
    }
  }, _callee2, undefined);
})));

test("passes received errors to children as render prop", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
  var _render3, getByText;

  return regeneratorRuntime.wrap(function _callee3$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _render3 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            function (_ref6) {
              var errors = _ref6.errors;
              return errors.map(function (e) {
                return e.error;
              }).join();
            }
          )), getByText = _render3.getByText;

          worker.onerror({ error: "foo" });
          worker.onerror({ error: "bar" });
          worker.onerror({ error: "baz" });
          _context3.next = 6;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("foo,bar,baz");
          });

        case 6:
        case "end":
          return _context3.stop();
      }
    }
  }, _callee3, undefined);
})));

test("passes last received error to children as render prop", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
  var _render4, getByText;

  return regeneratorRuntime.wrap(function _callee4$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _render4 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            function (_ref8) {
              var error = _ref8.error;
              return error;
            }
          )), getByText = _render4.getByText;

          worker.onerror({ error: "foo" });
          worker.onerror({ error: "bar" });
          worker.onerror({ error: "baz" });
          _context4.next = 6;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("baz");
          });

        case 6:
        case "end":
          return _context4.stop();
      }
    }
  }, _callee4, undefined);
})));

test("passes updatedAt date when a message is received", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
  var date, _render5, getByText, queryByText;

  return regeneratorRuntime.wrap(function _callee5$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          date = new Date().toISOString().substr(0, 10);
          _render5 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            function (_ref10) {
              var updatedAt = _ref10.updatedAt;
              return updatedAt ? updatedAt.toISOString().substr(0, 10) : null;
            }
          )), getByText = _render5.getByText, queryByText = _render5.queryByText;

          expect(queryByText(date)).toBeNull();
          worker.onmessage({ data: "foo" });
          _context5.next = 6;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText(date);
          });

        case 6:
        case "end":
          return _context5.stop();
      }
    }
  }, _callee5, undefined);
})));

test("passes updatedAt date when an error is received", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
  var date, _render6, getByText, queryByText;

  return regeneratorRuntime.wrap(function _callee6$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          date = new Date().toISOString().substr(0, 10);
          _render6 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            function (_ref12) {
              var updatedAt = _ref12.updatedAt;
              return updatedAt ? updatedAt.toISOString().substr(0, 10) : null;
            }
          )), getByText = _render6.getByText, queryByText = _render6.queryByText;

          expect(queryByText(date)).toBeNull();
          worker.onerror({ error: "foo" });
          _context6.next = 6;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText(date);
          });

        case 6:
        case "end":
          return _context6.stop();
      }
    }
  }, _callee6, undefined);
})));

test("invokes onMessage callback with message data when a message is received", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
  var onMessage;
  return regeneratorRuntime.wrap(function _callee7$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          onMessage = jest.fn();

          (0, _reactTestingLibrary.render)(_react2.default.createElement(_2.default, { url: "/worker.js", onMessage: onMessage }));
          worker.onmessage({ data: "foo" });
          expect(onMessage).toHaveBeenCalledWith("foo");

        case 4:
        case "end":
          return _context7.stop();
      }
    }
  }, _callee7, undefined);
})));

test("invokes onError callback with error when a error is received", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
  var onError;
  return regeneratorRuntime.wrap(function _callee8$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          onError = jest.fn();

          (0, _reactTestingLibrary.render)(_react2.default.createElement(_2.default, { url: "/worker.js", onError: onError }));
          worker.onerror({ error: "foo" });
          expect(onError).toHaveBeenCalledWith("foo");

        case 4:
        case "end":
          return _context8.stop();
      }
    }
  }, _callee8, undefined);
})));

test("terminates the worker when unmounted", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
  var _render7, unmount;

  return regeneratorRuntime.wrap(function _callee9$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          worker.terminate.mockClear();
          _render7 = (0, _reactTestingLibrary.render)(_react2.default.createElement(_2.default, { url: "/worker.js" })), unmount = _render7.unmount;

          unmount();
          expect(worker.terminate).toHaveBeenCalled();

        case 4:
        case "end":
          return _context9.stop();
      }
    }
  }, _callee9, undefined);
})));

test("postMessage sends messages to the worker", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
  var _render8, getByText;

  return regeneratorRuntime.wrap(function _callee10$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          worker.postMessage.mockClear();
          _render8 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            function (_ref17) {
              var postMessage = _ref17.postMessage;
              return _react2.default.createElement(
                "button",
                { onClick: function onClick() {
                    return postMessage("hello");
                  } },
                "go"
              );
            }
          )), getByText = _render8.getByText;

          expect(worker.postMessage).not.toHaveBeenCalled();
          _reactTestingLibrary.fireEvent.click(getByText("go"));
          expect(worker.postMessage).toHaveBeenCalledWith("hello");

        case 5:
        case "end":
          return _context10.stop();
      }
    }
  }, _callee10, undefined);
})));

test("calling postMessage before having setup a worker will throw", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
  return regeneratorRuntime.wrap(function _callee11$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            function (_ref19) {
              var postMessage = _ref19.postMessage;

              expect(function () {
                return postMessage("hello");
              }).toThrow(new Error("Worker not initialized"));
            }
          ));

        case 1:
        case "end":
          return _context11.stop();
      }
    }
  }, _callee11, undefined);
})));

test("serializer will prepare messages before sending them to the worker", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
  var _render9, getByText;

  return regeneratorRuntime.wrap(function _callee12$(_context12) {
    while (1) {
      switch (_context12.prev = _context12.next) {
        case 0:
          worker.postMessage.mockClear();
          _render9 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js", serializer: JSON.stringify },
            function (_ref21) {
              var postMessage = _ref21.postMessage;
              return _react2.default.createElement(
                "button",
                { onClick: function onClick() {
                    return postMessage({ foo: "bar" });
                  } },
                "go"
              );
            }
          )), getByText = _render9.getByText;

          expect(worker.postMessage).not.toHaveBeenCalled();
          _reactTestingLibrary.fireEvent.click(getByText("go"));
          expect(worker.postMessage).toHaveBeenCalledWith(JSON.stringify({ foo: "bar" }));

        case 5:
        case "end":
          return _context12.stop();
      }
    }
  }, _callee12, undefined);
})));

test("parser will deserialize messages received from the worker", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
  var onMessage, _render10, getByText;

  return regeneratorRuntime.wrap(function _callee13$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          onMessage = jest.fn();
          _render10 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js", parser: JSON.parse, onMessage: onMessage },
            function (_ref23) {
              var data = _ref23.data;
              return data && data.foo;
            }
          )), getByText = _render10.getByText;

          worker.onmessage({ data: JSON.stringify({ foo: "bar" }) });
          expect(onMessage).toHaveBeenCalledWith({ foo: "bar" });
          _context13.next = 6;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("bar");
          });

        case 6:
        case "end":
          return _context13.stop();
      }
    }
  }, _callee13, undefined);
})));

test("supports passing a custom Worker instance", function () {
  var onMessage = jest.fn();
  var customWorker = { onmessage: null, postMessage: jest.fn() };

  var _render11 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
    _2.default,
    { worker: customWorker, onMessage: onMessage },
    function (_ref24) {
      var postMessage = _ref24.postMessage;
      return _react2.default.createElement(
        "button",
        { onClick: function onClick() {
            return postMessage("hello");
          } },
        "go"
      );
    }
  )),
      getByText = _render11.getByText;

  customWorker.onmessage({ data: "foo" });
  expect(onMessage).toHaveBeenCalledWith("foo");
  expect(customWorker.postMessage).not.toHaveBeenCalled();
  _reactTestingLibrary.fireEvent.click(getByText("go"));
  expect(customWorker.postMessage).toHaveBeenCalledWith("hello");
});

test("custom workers don't terminate on unmount", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
  var customWorker, _render12, unmount;

  return regeneratorRuntime.wrap(function _callee14$(_context14) {
    while (1) {
      switch (_context14.prev = _context14.next) {
        case 0:
          customWorker = { terminate: jest.fn() };
          _render12 = (0, _reactTestingLibrary.render)(_react2.default.createElement(_2.default, { worker: customWorker })), unmount = _render12.unmount;

          unmount();
          expect(customWorker.terminate).not.toHaveBeenCalled();

        case 4:
        case "end":
          return _context14.stop();
      }
    }
  }, _callee14, undefined);
})));

test("supports Service Workers", function () {
  var onMessage = jest.fn();
  var customWorker = window.ServiceWorker();

  var _render13 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
    _2.default,
    { worker: customWorker, onMessage: onMessage },
    function (_ref26) {
      var postMessage = _ref26.postMessage;
      return _react2.default.createElement(
        "button",
        { onClick: function onClick() {
            return postMessage("hello");
          } },
        "go"
      );
    }
  )),
      getByText = _render13.getByText;

  expect(customWorker.postMessage).not.toHaveBeenCalled();
  _reactTestingLibrary.fireEvent.click(getByText("go"));
  expect(customWorker.postMessage).toHaveBeenCalledWith("hello", [messageChannel.port2]);
});

test("WebWorker.Data renders with last message data only when a message has been received", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
  var _render14, getByText, queryByText;

  return regeneratorRuntime.wrap(function _callee15$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          _render14 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            _react2.default.createElement(
              _2.default.Data,
              null,
              function (data) {
                return data;
              }
            )
          )), getByText = _render14.getByText, queryByText = _render14.queryByText;

          expect(queryByText("foo")).toBeNull();
          worker.onmessage({ data: "foo" });
          _context15.next = 5;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("foo");
          });

        case 5:
          worker.onmessage({ data: "bar" });
          _context15.next = 8;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("bar");
          });

        case 8:
          worker.onmessage({ data: "baz" });
          _context15.next = 11;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("baz");
          });

        case 11:
        case "end":
          return _context15.stop();
      }
    }
  }, _callee15, undefined);
})));

test("WebWorker.Error renders with last error only when an error has been received", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
  var _render15, getByText, queryByText;

  return regeneratorRuntime.wrap(function _callee16$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:
          _render15 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            _react2.default.createElement(
              _2.default.Error,
              null,
              function (error) {
                return error;
              }
            )
          )), getByText = _render15.getByText, queryByText = _render15.queryByText;

          expect(queryByText("foo")).toBeNull();
          worker.onerror({ error: "foo" });
          _context16.next = 5;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("foo");
          });

        case 5:
          worker.onerror({ error: "bar" });
          _context16.next = 8;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("bar");
          });

        case 8:
          worker.onerror({ error: "baz" });
          _context16.next = 11;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("baz");
          });

        case 11:
        case "end":
          return _context16.stop();
      }
    }
  }, _callee16, undefined);
})));

test("WebWorker.Pending renders only when no message has been received yet", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
  var _render16, getByText, queryByText;

  return regeneratorRuntime.wrap(function _callee17$(_context17) {
    while (1) {
      switch (_context17.prev = _context17.next) {
        case 0:
          _render16 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            _react2.default.createElement(
              _2.default.Pending,
              null,
              "pending"
            )
          )), getByText = _render16.getByText, queryByText = _render16.queryByText;
          _context17.next = 3;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("pending");
          });

        case 3:
          worker.onmessage({ data: "foo" });
          expect(queryByText("pending")).toBeNull();

        case 5:
        case "end":
          return _context17.stop();
      }
    }
  }, _callee17, undefined);
})));

test("WebWorker.Pending renders only when no error has been received yet", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
  var _render17, getByText, queryByText;

  return regeneratorRuntime.wrap(function _callee18$(_context18) {
    while (1) {
      switch (_context18.prev = _context18.next) {
        case 0:
          _render17 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            _react2.default.createElement(
              _2.default.Pending,
              null,
              "pending"
            )
          )), getByText = _render17.getByText, queryByText = _render17.queryByText;
          _context18.next = 3;
          return (0, _reactTestingLibrary.waitForElement)(function () {
            return getByText("pending");
          });

        case 3:
          worker.onerror({ error: "foo" });
          expect(queryByText("pending")).toBeNull();

        case 5:
        case "end":
          return _context18.stop();
      }
    }
  }, _callee18, undefined);
})));

test("An unrelated change in props does not update the Context", _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
  var one, two, _render18, rerender;

  return regeneratorRuntime.wrap(function _callee19$(_context19) {
    while (1) {
      switch (_context19.prev = _context19.next) {
        case 0:
          one = void 0;
          two = void 0;
          _render18 = (0, _reactTestingLibrary.render)(_react2.default.createElement(
            _2.default,
            { url: "/worker.js" },
            _react2.default.createElement(
              _2.default.Pending,
              null,
              function (value) {
                one = value;
              }
            )
          )), rerender = _render18.rerender;

          rerender(_react2.default.createElement(
            _2.default,
            { url: "/worker.js", someProp: true },
            _react2.default.createElement(
              _2.default.Pending,
              null,
              function (value) {
                two = value;
              }
            )
          ));
          expect(one).toBe(two);

        case 5:
        case "end":
          return _context19.stop();
      }
    }
  }, _callee19, undefined);
})));